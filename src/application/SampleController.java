package application;

import javafx.fxml.FXML;
import javafx.scene.control.Button;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.ContentDisplay;
import javafx.scene.control.Label;
import javafx.scene.control.RadioButton;
import javafx.scene.control.TextField;
import javafx.scene.control.ToggleGroup;
import javafx.stage.Stage;
import java.lang.Math;
import java.awt.geom.PathIterator;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;

@SuppressWarnings("unused")
public class SampleController {
	private LinkedList<City> city = new LinkedList<City>();
	private File f = new File("data.txt");
	String startingPointText = new String("Ramallah");
	String goalPointText = new String("Ramallah");

	ArrayList<String> results = new ArrayList<>();
	LinkedList<City> path = new LinkedList<>();

	ObservableList<String> ol = FXCollections.observableArrayList("DFS", "BFS", "Greedy", "A*");

	@FXML
	private Label label;
	@FXML
	private Label label1;
	@FXML
	private TextField fromTextField;
	@FXML
	private TextField toTextField;
	@FXML
	private ChoiceBox<String> cb;

	@FXML
	private Button starting;
	@FXML
	private Button endingPoint;
	@FXML
	private Button start;
	@FXML
	private ToggleGroup tg;

	
	@FXML
	public void toTextFieldAction(ActionEvent event) {
		// TODO Autogenerated
		Stage mainWindow = (Stage) toTextField.getScene().getWindow();
		String title = fromTextField.getText();
		mainWindow.setTitle(title);

	}

	@FXML
	private void initialize() {
		// Background color of the control itself

		label.setContentDisplay(ContentDisplay.TOP);
		
		cb.getStylesheets().add("application.css");// scene.getStylesheets().add("yourname.css")

		// cb.setStyle("-fx-text-fill: green;");
		cb.setItems(ol);

		cb.setValue("DFS");
		try {
			String[] cities = null;
			Scanner input = new Scanner(f);
			for (int i = 0; input.hasNext(); ++i) {
				if (i == 0) {
					cities = input.nextLine().trim().split(" ");
				}

				else {
					String[] splitter = input.nextLine().trim().split(" ");
					City c = new City(splitter[0]);
					for (int j = 0; j < cities.length && j < splitter.length - 1; ++j) {
						String[] distances = splitter[j + 1].trim().split(",");
						if (distances.length != 1)
							c.getDistenations().insertion(new Dest(cities[j], Integer.parseInt(distances[0]),
									(Integer.parseInt(distances[1].trim()) + Integer.parseInt(distances[0])) / 2,
									Integer.parseInt(distances[1].trim()), splitter[0]));
						else
							c.getDistenations().insertion(
									new Dest(cities[j], Integer.parseInt(distances[0]), -1, -1, splitter[0]));
					}
					city.insertion(c);

				}

			}
			City c = new City("Ramallah");
			Dest d = new Dest("Nablus");
			// System.out.println(city.find(c).getData().getDistenations().find(d).toString());

			// System.out.println(city.toString());
			input.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	@FXML
	private void StartingButtonPoint(ActionEvent e) {
		if (starting.isArmed()) {
			startingPointText = ((RadioButton) tg.getSelectedToggle()).getText();
			starting.setText(startingPointText);
		}
	}

	@FXML
	private void goalButtonPoint(ActionEvent e) {

		if (endingPoint.isArmed()) {
			goalPointText = ((RadioButton) tg.getSelectedToggle()).getText();
			endingPoint.setText(goalPointText);
		}
	}

	private boolean Poped(String child, ArrayList<String> poped) {
		for (int i = 0; i < poped.size(); ++i)
			if (poped.get(i).equals(child))
				return false;

		return true;
	}

	@FXML
	private void starting(ActionEvent e) { // not ready
		if (start.isArmed()) {
			label1.setText("");
			path = new LinkedList<>();
			// BFS
			if (cb.getValue().equals("BFS")) {
				Queue<City> Fringe = new Queue<>();
				int walkingcost = 0;
				int drivingCost = 0;
				int arialCost = 0;
				City parent = null; // To Set The Parent
				ArrayList<String> poped = new ArrayList<>();

				if (!startingPointText.equals(goalPointText)) { // If it was not at the first
					Fringe.enqueue(city.find(new City(startingPointText)).getData());
					while (true) { // Keep looping until you find the destination

						parent = Fringe.getFront(); // For Parent City
						Node<Dest> childDest = Fringe.getFront().getDistenations().find(new Dest(goalPointText));
						if (childDest.getData().getDrivingCost() != -1) { // If we Reached The
																			// Destination
							City dist = city.find(new City(goalPointText)).getData();
							dist.parent = parent;
							dist.setArialCost(childDest.getData().getArialCost()); // set the distances
							dist.setArialCost(childDest.getData().getWalkingCost()); // from Dest -> City
							dist.setArialCost(childDest.getData().getDrivingCost()); // the 3 Distances
							Fringe.enqueue(dist);
							parent = dist;
							break;
						}

						else { // If Distination was not reached yet !
							results = Fringe.getFront().findDistenations(); // Get The Children Names To The ArrayList

							for (int i = 0; i < results.size(); ++i) { // Loop To Add The Cities From ArrayList To
																		// Fringe
								if (!results.get(i).equals(parent.getName()) && Poped(results.get(i), poped)
										&& !results.get(i).equals(startingPointText)) {
									childDest = Fringe.getFront().getDistenations().find(new Dest(results.get(i)));
									Node<City> child = city.find(new City(results.get(i)));

									child.getData().setArialCost(childDest.getData().getArialCost()); // set the
																										// distances
									child.getData().setDrivingCost(childDest.getData().getDrivingCost()); // from Dest
																											// -> City
									child.getData().setWalkingCost(childDest.getData().getWalkingCost()); // the 3
																											// Distances
									child.getData().parent = parent; // Set The Parent City
									Fringe.enqueue(child.getData());
								}
							}
						}

						parent = Fringe.dequeue();
						poped.add(parent.getName().trim());

					}
					City current = Fringe.getLast().getData();

					while (!current.getName().equals(startingPointText)) {
						path.insert(current);
						walkingcost += current.getWalkingCost();
						drivingCost += current.getDrivingCost();
						current = current.parent;
					}
					path.insert(current);
					arialCost = current.getDistenations().find(new Dest(goalPointText)).getData().getArialCost();

				} else { // If The Starting Point Is The Goal
					path.insert(city.find(new City(startingPointText)).getData());
				}
				label.setText(path.tostring() + "\n	" + "Total Driving Cost = " + Integer.toString(drivingCost)
						+ "km\n	" + "Total Arial Cost = " + Integer.toString(arialCost) + "km\n	"
						+ "Total Walking Cost = " + Integer.toString(walkingcost) + "km");

			}

			/////////////////////////////////////////////////////////////////////////

			// DFS
			else if (cb.getValue().equals("DFS")) {

				Stack<City> Fringe = new Stack<>();
				int walkingcost = 0;
				int drivingCost = 0;
				int arialCost = 0;
				City parent = null; // To Set The Parent
				ArrayList<String> poped = new ArrayList<>();

				if (!startingPointText.equals(goalPointText)) { // If it was not at the first
					Fringe.push(city.find(new City(startingPointText)).getData());
					parent = Fringe.peek().getData();
					poped.add(parent.getName());
					parent.parent = null;
					while (true) { // Keep looping until you find the destination

						if (Fringe.peek() == null)
							break;

						// parent = Fringe.peek().getData(); // For Parent City
						Node<Dest> childDest = parent.getDistenations().find(new Dest(goalPointText));

						if (childDest.getData().getDrivingCost() != -1) { // If we Reached The Destination
							City dist = city.find(new City(goalPointText)).getData();
							dist.parent = parent;
							dist.setArialCost(childDest.getData().getArialCost()); // set the distances
							dist.setArialCost(childDest.getData().getWalkingCost()); // from Dest -> City
							dist.setArialCost(childDest.getData().getDrivingCost()); // the 3 Distances
							Fringe.push(dist);
							parent = dist;
							break;
						}

						else { // If Distination was not reached yet !
							results = parent.findDistenations(); // Get The Children Names To The ArrayList

							for (int i = 0; i < results.size(); ++i) { // Loop To Add The Cities From ArrayList To
								if (!results.get(i).equals(parent.getName()) && Poped(results.get(i), poped)) {
									childDest = parent.getDistenations().find(new Dest(results.get(i)));
									Node<City> child = city.find(new City(results.get(i)));

									child.getData().setArialCost(childDest.getData().getArialCost()); // set the
																										// distances
									child.getData().setDrivingCost(childDest.getData().getDrivingCost()); // from Dest
																											// -> City
									child.getData().setWalkingCost(childDest.getData().getWalkingCost()); // the 3
																											// Distances
									child.getData().parent = parent; // Set The Parent City
									Fringe.push(child.getData());

								}
//								
//								else if (i == (results.size() - 1) && !Poped(results.get(i), poped) && parent.parent != null) {
//									parent = parent.parent;
//									results = parent.findDistenations();
//									System.out.println("parenting");
//									i = -1;
//								}
//								
//								else if(Poped(results.get(i) , poped))
//									System.out.println("parent = " + parent);
							} // end for
						} // end else

						if (Poped(Fringe.peek().getData().getName(), poped)) {
							parent = Fringe.pop().getData();
							poped.add(parent.getName().trim());
						} else if (parent.parent != null) {
							parent = parent.parent;

						}
					} // end while

					/////////////////////////////////
					/*
					 * printing
					 */
					////////////////////////////////

					City current = parent;
					path = new LinkedList<City>();
					while (!current.getName().equals(startingPointText)) {
						path.insert(current);
						walkingcost += current.getWalkingCost();
						drivingCost += current.getDrivingCost();
						current = current.parent;
					}
					path.insert(current);
					arialCost = current.getDistenations().find(new Dest(goalPointText)).getData().getArialCost();
				}

				else { // If The Starting Point Is The Goal
					path.insert(city.find(new City(startingPointText)).getData());
				}

				label.setText(path.tostring() + "\n" + "Total Driving Cost = " + Integer.toString(drivingCost) + "\n"
						+ "Total Arial Cost = " + Integer.toString(arialCost) + "\n" + "Total Walking Cost = "
						+ Integer.toString(walkingcost));

			} else if (cb.getValue().equals("Greedy")) {
				// Greedy

				int walkingcost = 0;
				int drivingCost = 0;
				int arialCost = 0;
				LinkedList<City> Fringe = new LinkedList<>();
				City parent = null; // To Set The Parent
				String s = new String("Nablus");
				City goal = city.find(new City(goalPointText)).getData();
				ArrayList<String> poped = new ArrayList<>();
				ArrayList<Integer> H = new ArrayList<>();
				parent = city.find(new City(startingPointText)).getData();
				parent.totalCost = 0;
				LinkedList<City> path1 = new LinkedList<>();
				parent.parent = null;
				parent.setArialCost(city.find(new City(startingPointText)).getData().getArialCost());
				if (!startingPointText.equals(goalPointText)) { // If it was not at the first
					
					Fringe.insert(parent); // will be back
					// goal.getDistenations().find(new
					// Dest(child.getData().getName())).getData().getArialCost()
					// For Parent City
					path.insert(parent);
					
					while (true) { // Keep looping until you find the destination

						if (parent.getName().equals(goalPointText)) {
							break;
						}

						Node<Dest> childDest;

						results = parent.findDistenations(); // Get The Children Names To The ArrayList

						for (int i = 0; i < results.size(); ++i) { // Loop To Add The Cities From ArrayList To
																	// Fringe
							if (!results.get(i).equals(parent.getName()) && Poped(results.get(i), poped)
									&& !results.get(i).equals(startingPointText)) {
								childDest = parent.getDistenations().find(new Dest(results.get(i)));
								Node<City> child = city.find(new City(results.get(i)));
								// set the
								// distances
								child.getData().setArialCost(goal.getDistenations()
										.find(new Dest(child.getData().getName())).getData().getArialCost());

								child.getData().setDrivingCost(childDest.getData().getDrivingCost());
								// from Dest -> City

								child.getData().setWalkingCost(childDest.getData().getWalkingCost());
								// the 3
								// Distances

								child.getData().totalCost = child.getData().getDrivingCost() + parent.totalCost;

								child.getData().parent = parent; // Set The Parent City
								City c = new City(child.getData().getName(), child.getData().getArialCost(),
										child.getData().getWalkingCost(), child.getData().getDrivingCost(),
										child.getData().getDistenations(), child.getData().parent,
										child.getData().totalCost);
								Fringe.insert(c);
								
							}
						}						
						if (Fringe.delete(parent) == null) {
							if(parent.parent == null)
								break ;
							City c = new City(parent.parent.getName(), parent.parent.getArialCost(),
									parent.parent.getWalkingCost(), parent.parent.getDrivingCost(),
									parent.parent.getDistenations(), parent,
									parent.parent.totalCost+parent.totalCost);
							path.insert(c);
							parent = parent.parent ;
							
							}
						else {
							
						poped.add(parent.getName().trim());}
						
						City temp = greedy(parent,Fringe, poped).getData();
						if(temp != parent) {
							path.insert(temp);
							parent = temp ;}
						
						
					}
				}
				
				Node<City> current = path.getHead();
				if (parent.getName().equals(goalPointText)) {
					while (!current.getData().getName().equals(startingPointText)) {
						walkingcost += current.getData().getWalkingCost();
						drivingCost += current.getData().getDrivingCost();
						current = current.getNext();
					}
				City c = parent;
				while(!c.getName().equals(startingPointText)) {
					path1.insert(c);
					c = c.parent ;
				}
					path1.insert(c);
					arialCost = path.find(new City(startingPointText)).getData().getDistenations().find(new Dest(goalPointText)).getData().getArialCost();

					label.setText(path1.tostring() + "\n" + "	Total Arial Cost = " + Integer.toString(arialCost)
							+ "km\n" + "\n" + "	Total Driving Cost = " + Integer.toString(drivingCost) + "km");
				}

				else
					label.setText("No path found");
			}
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

			// A*

			else {
				// A* Algorithm

				int walkingcost = 0;
				int drivingCost = 0;
				int arialCost = 0;
				LinkedList<City> Fringe = new LinkedList<>();
				City parent = null; // To Set The Parent
				City goal = city.find(new City(goalPointText)).getData();
				ArrayList<String> poped = new ArrayList<>();

				if (!startingPointText.equals(goalPointText)) { // If it was not at the first
					parent = city.find(new City(startingPointText)).getData();
					parent.totalCost = 0;
					parent.parent = null;
					parent.setArialCost(city.find(new City(startingPointText)).getData().getArialCost());
					Fringe.insert(parent);
					
					while (true) { // Keep looping until you find the destination
						if (parent.getName().equals(goalPointText)) {
							break;
						}

						Node<Dest> childDest;

						results = parent.findDistenations(); // Get The Children Names To The ArrayList

						for (int i = 0; i < results.size(); ++i) { // Loop To Add The Cities From ArrayList To
																	// Fringe
							if (!results.get(i).equals(parent.getName()) && Poped(results.get(i), poped)
									&& !results.get(i).equals(startingPointText)
									&& !results.get(i).equals(parent.getName())) {
								childDest = parent.getDistenations().find(new Dest(results.get(i)));
								Node<City> child = city.find(new City(results.get(i)));
								// set the
								// distances
								child.getData().setArialCost(goal.getDistenations()
										.find(new Dest(child.getData().getName())).getData().getArialCost());

								child.getData().setDrivingCost(childDest.getData().getDrivingCost());
								// from Dest -> City

								child.getData().setWalkingCost(childDest.getData().getWalkingCost());
								// the 3
								// Distances

								child.getData().totalCost = child.getData().getWalkingCost() + parent.totalCost;

								child.getData().parent = parent; // Set The Parent City
								City c = new City(child.getData().getName(), child.getData().getArialCost(),
										child.getData().getWalkingCost(), child.getData().getDrivingCost(),
										child.getData().getDistenations(), child.getData().parent,
										child.getData().totalCost);
								Fringe.insert(c);
							}
						}

						while (Fringe.delete(parent) != null)
							continue;

						poped.add(parent.getName());
						parent = minH(Fringe, parent).getData();

					}

					City current = parent;

					while (!current.getName().equals(startingPointText)) {
						path.insert(current);
						walkingcost += current.getWalkingCost();

						current = current.parent;
					}
					path.insert(current);
					arialCost = current.getDistenations().find(new Dest(goalPointText)).getData().getArialCost();
				} else // If The Starting Point Is The Goal
					path.insertion(city.find(new City(startingPointText)).getData());

				label.setText(path.toString() + "\n	" + "Total Arial Cost = " + Integer.toString(arialCost) + "km\n	"
						+ "Total Walking Cost = " + Integer.toString(walkingcost) + "km");

				/////////////////////////////////////////////
				/////////////////////////////
				/*
				 * h2
				 */
				////////////////////////////
				/////////////////////////////////////////////

				Fringe = new LinkedList<>();

				goal = city.find(new City(goalPointText)).getData();
				poped = new ArrayList<>();

				if (!startingPointText.equals(goalPointText)) { // If it was not at the first
					parent = city.find(new City(startingPointText)).getData();
					parent.totalCost = 0;
					parent.parent = null;
					parent.setArialCost(walkingcost);
					Fringe.insert(parent);
					walkingcost = 0;
					drivingCost = 0;
					arialCost = 0;
					
					while (true) { // Keep looping until you find the destination

						if (parent.getName().equals(goalPointText)) {
							break;
						}

						Node<Dest> childDest;

						results = parent.findDistenations(); // Get The Children Names To The ArrayList

						for (int i = 0; i < results.size(); ++i) { // Loop To Add The Cities From ArrayList To
																	// Fringe
							if (!results.get(i).equals(parent.getName()) && Poped(results.get(i), poped)
									&& !results.get(i).equals(startingPointText)) {
								childDest = parent.getDistenations().find(new Dest(results.get(i)));
								Node<City> child = city.find(new City(results.get(i)));
								// set the
								// distances
								child.getData().setArialCost(goal.getDistenations()
										.find(new Dest(child.getData().getName())).getData().getArialCost());

								child.getData().setDrivingCost(childDest.getData().getDrivingCost());
								// from Dest -> City

								child.getData().setWalkingCost(childDest.getData().getWalkingCost());
								// the 3
								// Distances

								child.getData().totalCost = child.getData().getDrivingCost() + parent.totalCost;

								child.getData().parent = parent; // Set The Parent City

								City c = new City(child.getData().getName(), child.getData().getArialCost(),
										child.getData().getWalkingCost(), child.getData().getDrivingCost(),
										child.getData().getDistenations(), child.getData().parent,
										child.getData().totalCost);
								Fringe.insert(c);
								// System.out.println("child = " + child);

							}
						}
						
						while (Fringe.delete(parent) != null)
							continue;
						poped.add(parent.getName());

						parent = minH1(Fringe, parent).getData();
					}
					path = new LinkedList<City>();
					City current = parent;
					

					while (!current.getName().equals(startingPointText)) {
						path.insert(current);
						walkingcost += current.getWalkingCost();
						drivingCost += current.getDrivingCost();

						current = current.parent;

					}
					path.insert(current);
					arialCost = current.getDistenations().find(new Dest(goalPointText)).getData().getArialCost();
				}

				else // If The Starting Point Is The Goal
					path.insertion(city.find(new City(startingPointText)).getData());

				label1.setText(path.toString() + "	" + "Total Driving Cost = " + Integer.toString(drivingCost) + "km");

			}
		}
	}

	private Node<City> minH(LinkedList<City> Fringe, City parent) {
		if (Fringe.getHead() != null) {

			Node<City> p = Fringe.getHead();
			int min = p.getData().totalCost;
			Node<City> result = p;
			while (p != null) {
				if (min + result.getData().getArialCost() > p.getData().totalCost + p.getData().getArialCost()) {
					min = p.getData().totalCost;
					result = p;
				}
				p = p.getNext();
			}
			// Fringe.delete(result.getData());
			return result;
		}

		return null;
	}
	
	
	
	///////////////////////////////////////////////////////////////////////
	
	

	private Node<City> greedy(City parent ,LinkedList<City> Fringe, ArrayList<String> poped) {
		if (Fringe.getHead() != null) {
System.out.println("parent in greedy = "+parent);
			Node<City> p = Fringe.getHead();
			int min = p.getData().getDrivingCost();
			Node<City> result = p;
		//	System.out.printf("\t\t\t\t\t\t\t\tparent = "+parent);
			while (p != null) {
				if(parent.getName().equals("Sabastia"))
				if((!p.getData().getName().equals(parent.getName()))
						&&parent.getName().equals("Sabastia")&&parent.getDistenations().find(new Dest(p.getData().getName())).getData().getWalkingCost()!=-1) {

			}
				if ((!p.getData().getName().equals(parent.getName())) && min > p.getData().getDrivingCost() && Poped(p.getData().getName(), poped) && parent.getDistenations().find(new Dest(p.getData().getName())).getData().getWalkingCost()!=-1) {
				min = p.getData().getDrivingCost();
					result = p;
				}
				p = p.getNext();
			}
			
			if(parent.getDistenations().find(new Dest(result.getData().getName())).getData().getWalkingCost()==-1) 
				return new Node<City>(parent) ;
			
			return result;

		}
		return null; // unreachable code :D
	}
	
	
	
//////////////////////////////////////////////////////////////////
	
	
	
	private Node<City> minH1(LinkedList<City> Fringe, City parent) {
		if (Fringe.getHead() != null) {

			Node<City> p = Fringe.getHead();
			int min = p.getData().totalCost;
			Node<City> result = p;
			while (p != null) {
				if (min + h2(result.getData().getName()) > p.getData().totalCost + h2(p.getData().getName())
						&& !p.getData().getName().equals(parent.getName())) {
					System.out.println("city = " +p.getData()+" h = " + h2(p.getData().getName()) + " cost = "+p.getData().totalCost);
					min = p.getData().totalCost ;
					result = p;
				}
				p = p.getNext();
			}
			
			
			return result;
		}

		return null;
	}

	private int h2(String node) {

		int walkingcost = 0;
		int drivingCost = 0;
		int arialCost = 0;

		LinkedList<City> Fringe = new LinkedList<>();
		City parent = null; // To Set The Parent
		City goal = city.find(new City(goalPointText)).getData();
		ArrayList<String> poped = new ArrayList<>();

		if (!node.equals(goalPointText)) { // If it was not at the first
			parent = city.find(new City(node)).getData();
			Fringe.insert(parent);

			while (true) { // Keep looping until you find the destination

				if (parent.getName().equals(goalPointText)) {
					break;
				}

				Node<Dest> childDest;

				results = parent.findDistenations(); // Get The Children Names To The ArrayList

				for (int i = 0; i < results.size(); ++i) { // Loop To Add The Cities From ArrayList To
															// Fringe
					if (!results.get(i).equals(parent.getName()) && Poped(results.get(i), poped)
							&& !results.get(i).equals(node) && !results.get(i).equals(parent.getName())) {
						childDest = parent.getDistenations().find(new Dest(results.get(i)));
						Node<City> child = city.find(new City(results.get(i)));
						// set the
						// distances
						child.getData().setArialCost(goal.getDistenations().find(new Dest(child.getData().getName()))
								.getData().getArialCost());

						child.getData().setDrivingCost(childDest.getData().getDrivingCost());
						// from Dest -> City

						child.getData().setWalkingCost(childDest.getData().getWalkingCost());
						// the 3
						// Distances

						child.getData().totalCost = child.getData().getDrivingCost() + parent.totalCost;

						child.getData().parent = parent; // Set The Parent City
						City c = new City(child.getData().getName(), child.getData().getArialCost(),
								child.getData().getWalkingCost(), child.getData().getDrivingCost(),
								child.getData().getDistenations(), child.getData().parent,
								child.getData().totalCost);
						Fringe.insert(c);
					}
				}

				if (Fringe.delete(parent) == null)
					continue;
				poped.add(parent.getName());
				parent = minH(Fringe, parent).getData();

			}
		} else
			return 0;

		while (!parent.getName().equals(node)) {
			walkingcost += parent.getWalkingCost();
			parent = parent.parent;
		}
		walkingcost += parent.getWalkingCost();
		return walkingcost;

	}

}
